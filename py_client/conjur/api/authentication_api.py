# coding: utf-8

"""
    Conjur

    This is an API definition for CyberArk Conjur Open Source. You can find out more at [Conjur.org](https://www.conjur.org/).  # noqa: E501

    The version of the OpenAPI document: 5.3.0
    Contact: conj_maintainers@cyberark.com
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from conjur.api_client import ApiClient
from conjur.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class AuthenticationApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def change_password(self, account, body, **kwargs):  # noqa: E501
        """Changes a user’s password.  # noqa: E501

        You must provide the login name and current password or API key of the user whose password is to be updated in an HTTP Basic Authentication header. Also replaces the user’s API key with a new securely generated random value. You can fetch the new API key using the Login method.  The Basic authentication-compliant header is formed by: 1. Concatenating the role's name, a literal colon character ':',    and the password or API key to create the authentication string. 2. Base64-encoding the authentication string. 3. Prefixing the authentication string with the scheme: `Basic `    (note the required space). 4. Providing the result as the value of the `Authorization` HTTP header:    `Authorization: Basic <authentication string>`.  Your HTTP/REST client probably provides HTTP basic authentication support. For example, `curl` and all of the Conjur client libraries provide this.  Note that machine roles (Hosts) do not have passwords. They authenticate using their API keys, while passwords are only used by human users.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_password(account, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account: Organization account name (required)
        :param str body: New password (required)
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.change_password_with_http_info(account, body, **kwargs)  # noqa: E501

    def change_password_with_http_info(self, account, body, **kwargs):  # noqa: E501
        """Changes a user’s password.  # noqa: E501

        You must provide the login name and current password or API key of the user whose password is to be updated in an HTTP Basic Authentication header. Also replaces the user’s API key with a new securely generated random value. You can fetch the new API key using the Login method.  The Basic authentication-compliant header is formed by: 1. Concatenating the role's name, a literal colon character ':',    and the password or API key to create the authentication string. 2. Base64-encoding the authentication string. 3. Prefixing the authentication string with the scheme: `Basic `    (note the required space). 4. Providing the result as the value of the `Authorization` HTTP header:    `Authorization: Basic <authentication string>`.  Your HTTP/REST client probably provides HTTP basic authentication support. For example, `curl` and all of the Conjur client libraries provide this.  Note that machine roles (Hosts) do not have passwords. They authenticate using their API keys, while passwords are only used by human users.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_password_with_http_info(account, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account: Organization account name (required)
        :param str body: New password (required)
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'account',
            'body',
            'x_request_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_password" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'account' is set
        if self.api_client.client_side_validation and ('account' not in local_var_params or  # noqa: E501
                                                        local_var_params['account'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `account` when calling `change_password`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `change_password`")  # noqa: E501

        if self.api_client.client_side_validation and ('account' in local_var_params and  # noqa: E501
                                                        len(local_var_params['account']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `account` when calling `change_password`, length must be greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and 'x_request_id' in local_var_params and not re.search(r'^[a-zA-Z\d-]{1,255}$', local_var_params['x_request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `x_request_id` when calling `change_password`, must conform to the pattern `/^[a-zA-Z\d-]{1,255}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'account' in local_var_params:
            path_params['account'] = local_var_params['account']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_request_id' in local_var_params:
            header_params['X-Request-Id'] = local_var_params['x_request_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/authn/{account}/password', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_authenticator(self, authenticator, account, **kwargs):  # noqa: E501
        """Enables or disables authenticator defined without service_id.  # noqa: E501

        Allows you to either enable or disable a given authenticator that does not have service_id (For example: authn-gcp).  When you enable or disable an authenticator via this endpoint, the status of the authenticator is stored in the Conjur database. The enablement status of the authenticator service may be overridden by setting the `CONJUR_AUTHENTICATORS` environment variable on the Conjur server; in the case where this environment variable is set, the database record of whether the authenticator service is enabled will be ignored.  **This endpoint is part of an early implementation of support for enabling Conjur authenticators via the API, and is currently available at the Community (or early alpha) level. This endpoint is still subject to breaking changes in the future.**   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_authenticator(authenticator, account, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ServiceAuthenticators authenticator: The authenticator to update (required)
        :param str account: Organization account name (required)
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param bool enabled:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.enable_authenticator_with_http_info(authenticator, account, **kwargs)  # noqa: E501

    def enable_authenticator_with_http_info(self, authenticator, account, **kwargs):  # noqa: E501
        """Enables or disables authenticator defined without service_id.  # noqa: E501

        Allows you to either enable or disable a given authenticator that does not have service_id (For example: authn-gcp).  When you enable or disable an authenticator via this endpoint, the status of the authenticator is stored in the Conjur database. The enablement status of the authenticator service may be overridden by setting the `CONJUR_AUTHENTICATORS` environment variable on the Conjur server; in the case where this environment variable is set, the database record of whether the authenticator service is enabled will be ignored.  **This endpoint is part of an early implementation of support for enabling Conjur authenticators via the API, and is currently available at the Community (or early alpha) level. This endpoint is still subject to breaking changes in the future.**   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_authenticator_with_http_info(authenticator, account, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ServiceAuthenticators authenticator: The authenticator to update (required)
        :param str account: Organization account name (required)
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param bool enabled:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'authenticator',
            'account',
            'x_request_id',
            'enabled'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_authenticator" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authenticator' is set
        if self.api_client.client_side_validation and ('authenticator' not in local_var_params or  # noqa: E501
                                                        local_var_params['authenticator'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `authenticator` when calling `enable_authenticator`")  # noqa: E501
        # verify the required parameter 'account' is set
        if self.api_client.client_side_validation and ('account' not in local_var_params or  # noqa: E501
                                                        local_var_params['account'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `account` when calling `enable_authenticator`")  # noqa: E501

        if self.api_client.client_side_validation and 'x_request_id' in local_var_params and not re.search(r'^[a-zA-Z\d-]{1,255}$', local_var_params['x_request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `x_request_id` when calling `enable_authenticator`, must conform to the pattern `/^[a-zA-Z\d-]{1,255}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'authenticator' in local_var_params:
            path_params['authenticator'] = local_var_params['authenticator']  # noqa: E501
        if 'account' in local_var_params:
            path_params['account'] = local_var_params['account']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_request_id' in local_var_params:
            header_params['X-Request-Id'] = local_var_params['x_request_id']  # noqa: E501

        form_params = []
        local_var_files = {}
        if 'enabled' in local_var_params:
            form_params.append(('enabled', local_var_params['enabled']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'conjurAuth', 'conjurKubernetesMutualTls']  # noqa: E501

        return self.api_client.call_api(
            '/{authenticator}/{account}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_authenticator_instance(self, authenticator, service_id, account, **kwargs):  # noqa: E501
        """Enables or disables authenticator service instances.  # noqa: E501

        Allows you to either enable or disable a given authenticator service instance.  When you enable or disable an authenticator service instance via this endpoint, the status of the authenticator service instance is stored in the Conjur database. The enablement status of the authenticator service instance may be overridden by setting the `CONJUR_AUTHENTICATORS` environment variable on the Conjur server; in the case where this environment variable is set, the database record of whether the authenticator service instance is enabled will be ignored.  **This endpoint is part of an early implementation of support for enabling Conjur authenticators via the API, and is currently available at the Community (or early alpha) level. This endpoint is still subject to breaking changes in the future.**   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_authenticator_instance(authenticator, service_id, account, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ServiceAuthenticators authenticator: The authenticator to update (required)
        :param str service_id: URL-Encoded authenticator service ID (required)
        :param str account: Organization account name (required)
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param bool enabled:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.enable_authenticator_instance_with_http_info(authenticator, service_id, account, **kwargs)  # noqa: E501

    def enable_authenticator_instance_with_http_info(self, authenticator, service_id, account, **kwargs):  # noqa: E501
        """Enables or disables authenticator service instances.  # noqa: E501

        Allows you to either enable or disable a given authenticator service instance.  When you enable or disable an authenticator service instance via this endpoint, the status of the authenticator service instance is stored in the Conjur database. The enablement status of the authenticator service instance may be overridden by setting the `CONJUR_AUTHENTICATORS` environment variable on the Conjur server; in the case where this environment variable is set, the database record of whether the authenticator service instance is enabled will be ignored.  **This endpoint is part of an early implementation of support for enabling Conjur authenticators via the API, and is currently available at the Community (or early alpha) level. This endpoint is still subject to breaking changes in the future.**   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_authenticator_instance_with_http_info(authenticator, service_id, account, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ServiceAuthenticators authenticator: The authenticator to update (required)
        :param str service_id: URL-Encoded authenticator service ID (required)
        :param str account: Organization account name (required)
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param bool enabled:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'authenticator',
            'service_id',
            'account',
            'x_request_id',
            'enabled'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_authenticator_instance" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authenticator' is set
        if self.api_client.client_side_validation and ('authenticator' not in local_var_params or  # noqa: E501
                                                        local_var_params['authenticator'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `authenticator` when calling `enable_authenticator_instance`")  # noqa: E501
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `enable_authenticator_instance`")  # noqa: E501
        # verify the required parameter 'account' is set
        if self.api_client.client_side_validation and ('account' not in local_var_params or  # noqa: E501
                                                        local_var_params['account'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `account` when calling `enable_authenticator_instance`")  # noqa: E501

        if self.api_client.client_side_validation and 'x_request_id' in local_var_params and not re.search(r'^[a-zA-Z\d-]{1,255}$', local_var_params['x_request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `x_request_id` when calling `enable_authenticator_instance`, must conform to the pattern `/^[a-zA-Z\d-]{1,255}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'authenticator' in local_var_params:
            path_params['authenticator'] = local_var_params['authenticator']  # noqa: E501
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501
        if 'account' in local_var_params:
            path_params['account'] = local_var_params['account']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_request_id' in local_var_params:
            header_params['X-Request-Id'] = local_var_params['x_request_id']  # noqa: E501

        form_params = []
        local_var_files = {}
        if 'enabled' in local_var_params:
            form_params.append(('enabled', local_var_params['enabled']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['conjurAuth']  # noqa: E501

        return self.api_client.call_api(
            '/{authenticator}/{service_id}/{account}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access_token(self, account, login, body, **kwargs):  # noqa: E501
        """Gets a short-lived access token, which is required in the header of most subsequent API requests.   # noqa: E501

        A client can obtain an access token by presenting a valid login name and API key.  The access token is used to communicate to the REST API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that was granted during authorization.  The `login` must be URL encoded. For example, `alice@devops` must be encoded as `alice%40devops`.  The `service_id`, if given, must be URL encoded. For example, `prod/gke` must be encoded as `prod%2Fgke`.  For host authentication, the `login` is the host ID with the prefix `host/`. For example, the host webserver would login as `host/webserver`, and would be encoded as `host%2Fwebserver`.  For API usage, the base64-encoded access token is ordinarily passed as an HTTP Authorization header as `Authorization: Token token=<base64-encoded token>`.  This is the default authentication endpoint only. See other endpoints for details on authenticating to Conjur using another method, e.g. for applications running in Azure or Kubernetes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_token(account, login, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account: Organization account name (required)
        :param str login: URL-encoded login name. For users, it’s the user ID. For hosts, the login name is `host/<host-id>` (required)
        :param str body: API Key (required)
        :param str accept_encoding: Setting the Accept-Encoding header to base64 will return a pre-encoded access token
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_access_token_with_http_info(account, login, body, **kwargs)  # noqa: E501

    def get_access_token_with_http_info(self, account, login, body, **kwargs):  # noqa: E501
        """Gets a short-lived access token, which is required in the header of most subsequent API requests.   # noqa: E501

        A client can obtain an access token by presenting a valid login name and API key.  The access token is used to communicate to the REST API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that was granted during authorization.  The `login` must be URL encoded. For example, `alice@devops` must be encoded as `alice%40devops`.  The `service_id`, if given, must be URL encoded. For example, `prod/gke` must be encoded as `prod%2Fgke`.  For host authentication, the `login` is the host ID with the prefix `host/`. For example, the host webserver would login as `host/webserver`, and would be encoded as `host%2Fwebserver`.  For API usage, the base64-encoded access token is ordinarily passed as an HTTP Authorization header as `Authorization: Token token=<base64-encoded token>`.  This is the default authentication endpoint only. See other endpoints for details on authenticating to Conjur using another method, e.g. for applications running in Azure or Kubernetes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_token_with_http_info(account, login, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account: Organization account name (required)
        :param str login: URL-encoded login name. For users, it’s the user ID. For hosts, the login name is `host/<host-id>` (required)
        :param str body: API Key (required)
        :param str accept_encoding: Setting the Accept-Encoding header to base64 will return a pre-encoded access token
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'account',
            'login',
            'body',
            'accept_encoding',
            'x_request_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_token" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'account' is set
        if self.api_client.client_side_validation and ('account' not in local_var_params or  # noqa: E501
                                                        local_var_params['account'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `account` when calling `get_access_token`")  # noqa: E501
        # verify the required parameter 'login' is set
        if self.api_client.client_side_validation and ('login' not in local_var_params or  # noqa: E501
                                                        local_var_params['login'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `login` when calling `get_access_token`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `get_access_token`")  # noqa: E501

        if self.api_client.client_side_validation and ('account' in local_var_params and  # noqa: E501
                                                        len(local_var_params['account']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `account` when calling `get_access_token`, length must be greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and ('login' in local_var_params and  # noqa: E501
                                                        len(local_var_params['login']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `login` when calling `get_access_token`, length must be greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and 'x_request_id' in local_var_params and not re.search(r'^[a-zA-Z\d-]{1,255}$', local_var_params['x_request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `x_request_id` when calling `get_access_token`, must conform to the pattern `/^[a-zA-Z\d-]{1,255}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'account' in local_var_params:
            path_params['account'] = local_var_params['account']  # noqa: E501
        if 'login' in local_var_params:
            path_params['login'] = local_var_params['login']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept_encoding' in local_var_params:
            header_params['Accept-Encoding'] = local_var_params['accept_encoding']  # noqa: E501
        if 'x_request_id' in local_var_params:
            header_params['X-Request-Id'] = local_var_params['x_request_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/authn/{account}/{login}/authenticate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access_token_via_aws(self, service_id, account, login, body, **kwargs):  # noqa: E501
        """Get a short-lived access token for applications running in AWS.  # noqa: E501

        The access token is used to communicate to the REST API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that was granted during authorization.  For API usage, the base64-encoded access token is ordinarily passed as an HTTP Authorization header as `Authorization: Token token=<base64-encoded token>`.  The `login` must be URL encoded and the host ID must have the prefix `host/`. For example, the host webserver would login as `host/webserver`, and would be encoded as `host%2Fwebserver`.  The `service_id`, if given, must be URL encoded. For example, `prod/gke` must be encoded as `prod%2Fgke`.  For detailed instructions on authenticating to Conjur using this endpoint, reference the documentation: [AWS IAM Authenticator](https://docs.conjur.org/Latest/en/Content/Operations/Services/AWS_IAM_Authenticator.htm) (`authn-iam`).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_token_via_aws(service_id, account, login, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: URL-Encoded authenticator service ID (required)
        :param str account: Organization account name (required)
        :param str login: URL-encoded login name. For hosts, the login name is `host/<host-id>` (required)
        :param str body: AWS Signature header (required)
        :param str accept_encoding: Setting the Accept-Encoding header to base64 will return a pre-encoded access token
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_access_token_via_aws_with_http_info(service_id, account, login, body, **kwargs)  # noqa: E501

    def get_access_token_via_aws_with_http_info(self, service_id, account, login, body, **kwargs):  # noqa: E501
        """Get a short-lived access token for applications running in AWS.  # noqa: E501

        The access token is used to communicate to the REST API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that was granted during authorization.  For API usage, the base64-encoded access token is ordinarily passed as an HTTP Authorization header as `Authorization: Token token=<base64-encoded token>`.  The `login` must be URL encoded and the host ID must have the prefix `host/`. For example, the host webserver would login as `host/webserver`, and would be encoded as `host%2Fwebserver`.  The `service_id`, if given, must be URL encoded. For example, `prod/gke` must be encoded as `prod%2Fgke`.  For detailed instructions on authenticating to Conjur using this endpoint, reference the documentation: [AWS IAM Authenticator](https://docs.conjur.org/Latest/en/Content/Operations/Services/AWS_IAM_Authenticator.htm) (`authn-iam`).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_token_via_aws_with_http_info(service_id, account, login, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: URL-Encoded authenticator service ID (required)
        :param str account: Organization account name (required)
        :param str login: URL-encoded login name. For hosts, the login name is `host/<host-id>` (required)
        :param str body: AWS Signature header (required)
        :param str accept_encoding: Setting the Accept-Encoding header to base64 will return a pre-encoded access token
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id',
            'account',
            'login',
            'body',
            'accept_encoding',
            'x_request_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_token_via_aws" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `get_access_token_via_aws`")  # noqa: E501
        # verify the required parameter 'account' is set
        if self.api_client.client_side_validation and ('account' not in local_var_params or  # noqa: E501
                                                        local_var_params['account'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `account` when calling `get_access_token_via_aws`")  # noqa: E501
        # verify the required parameter 'login' is set
        if self.api_client.client_side_validation and ('login' not in local_var_params or  # noqa: E501
                                                        local_var_params['login'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `login` when calling `get_access_token_via_aws`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `get_access_token_via_aws`")  # noqa: E501

        if self.api_client.client_side_validation and ('account' in local_var_params and  # noqa: E501
                                                        len(local_var_params['account']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `account` when calling `get_access_token_via_aws`, length must be greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and ('login' in local_var_params and  # noqa: E501
                                                        len(local_var_params['login']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `login` when calling `get_access_token_via_aws`, length must be greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and 'x_request_id' in local_var_params and not re.search(r'^[a-zA-Z\d-]{1,255}$', local_var_params['x_request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `x_request_id` when calling `get_access_token_via_aws`, must conform to the pattern `/^[a-zA-Z\d-]{1,255}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501
        if 'account' in local_var_params:
            path_params['account'] = local_var_params['account']  # noqa: E501
        if 'login' in local_var_params:
            path_params['login'] = local_var_params['login']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept_encoding' in local_var_params:
            header_params['Accept-Encoding'] = local_var_params['accept_encoding']  # noqa: E501
        if 'x_request_id' in local_var_params:
            header_params['X-Request-Id'] = local_var_params['x_request_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/authn-iam/{service_id}/{account}/{login}/authenticate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access_token_via_azure(self, service_id, account, login, **kwargs):  # noqa: E501
        """Gets a short-lived access token for applications running in Azure.  # noqa: E501

        The access token is used to communicate to the REST API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that was granted during authorization.  For API usage, the base64-encoded access token is ordinarily passed as an HTTP Authorization header as `Authorization: Token token=<base64-encoded token>`.  The `login` must be URL encoded and the host ID must have the prefix `host/`. For example, the host webserver would login as `host/webserver`, and would be encoded as `host%2Fwebserver`.  The `service_id`, if given, must be URL encoded. For example, `prod/gke` must be encoded as `prod%2Fgke`.  To authenticate to Conjur using this endpoint, reference the detailed documentation: [Azure Authenticator](https://docs.conjur.org/Latest/en/Content/Operations/Services/azure_authn.htm) (`authn-azure`).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_token_via_azure(service_id, account, login, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: URL-Encoded authenticator service ID (required)
        :param str account: Organization account name (required)
        :param str login: URL-encoded login name. For users, it’s the user ID. For hosts, the login name is `host/<host-id>` (required)
        :param str accept_encoding: Setting the Accept-Encoding header to base64 will return a pre-encoded access token
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param str jwt:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_access_token_via_azure_with_http_info(service_id, account, login, **kwargs)  # noqa: E501

    def get_access_token_via_azure_with_http_info(self, service_id, account, login, **kwargs):  # noqa: E501
        """Gets a short-lived access token for applications running in Azure.  # noqa: E501

        The access token is used to communicate to the REST API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that was granted during authorization.  For API usage, the base64-encoded access token is ordinarily passed as an HTTP Authorization header as `Authorization: Token token=<base64-encoded token>`.  The `login` must be URL encoded and the host ID must have the prefix `host/`. For example, the host webserver would login as `host/webserver`, and would be encoded as `host%2Fwebserver`.  The `service_id`, if given, must be URL encoded. For example, `prod/gke` must be encoded as `prod%2Fgke`.  To authenticate to Conjur using this endpoint, reference the detailed documentation: [Azure Authenticator](https://docs.conjur.org/Latest/en/Content/Operations/Services/azure_authn.htm) (`authn-azure`).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_token_via_azure_with_http_info(service_id, account, login, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: URL-Encoded authenticator service ID (required)
        :param str account: Organization account name (required)
        :param str login: URL-encoded login name. For users, it’s the user ID. For hosts, the login name is `host/<host-id>` (required)
        :param str accept_encoding: Setting the Accept-Encoding header to base64 will return a pre-encoded access token
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param str jwt:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id',
            'account',
            'login',
            'accept_encoding',
            'x_request_id',
            'jwt'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_token_via_azure" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `get_access_token_via_azure`")  # noqa: E501
        # verify the required parameter 'account' is set
        if self.api_client.client_side_validation and ('account' not in local_var_params or  # noqa: E501
                                                        local_var_params['account'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `account` when calling `get_access_token_via_azure`")  # noqa: E501
        # verify the required parameter 'login' is set
        if self.api_client.client_side_validation and ('login' not in local_var_params or  # noqa: E501
                                                        local_var_params['login'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `login` when calling `get_access_token_via_azure`")  # noqa: E501

        if self.api_client.client_side_validation and ('account' in local_var_params and  # noqa: E501
                                                        len(local_var_params['account']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `account` when calling `get_access_token_via_azure`, length must be greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and ('login' in local_var_params and  # noqa: E501
                                                        len(local_var_params['login']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `login` when calling `get_access_token_via_azure`, length must be greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and 'x_request_id' in local_var_params and not re.search(r'^[a-zA-Z\d-]{1,255}$', local_var_params['x_request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `x_request_id` when calling `get_access_token_via_azure`, must conform to the pattern `/^[a-zA-Z\d-]{1,255}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501
        if 'account' in local_var_params:
            path_params['account'] = local_var_params['account']  # noqa: E501
        if 'login' in local_var_params:
            path_params['login'] = local_var_params['login']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept_encoding' in local_var_params:
            header_params['Accept-Encoding'] = local_var_params['accept_encoding']  # noqa: E501
        if 'x_request_id' in local_var_params:
            header_params['X-Request-Id'] = local_var_params['x_request_id']  # noqa: E501

        form_params = []
        local_var_files = {}
        if 'jwt' in local_var_params:
            form_params.append(('jwt', local_var_params['jwt']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/authn-azure/{service_id}/{account}/{login}/authenticate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access_token_via_gcp(self, account, **kwargs):  # noqa: E501
        """Gets a short-lived access token for applications running in Google Cloud Platform.   # noqa: E501

        Use the GCP Authenticator API to send an authentication request from a Google Cloud service to Conjur.  For more information, see [the documentation](https://docs.conjur.org/Latest/en/Content/Operations/Services/cjr-gcp-authn.htm).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_token_via_gcp(account, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account: Organization account name (required)
        :param str accept_encoding: Setting the Accept-Encoding header to base64 will return a pre-encoded access token
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param str jwt:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_access_token_via_gcp_with_http_info(account, **kwargs)  # noqa: E501

    def get_access_token_via_gcp_with_http_info(self, account, **kwargs):  # noqa: E501
        """Gets a short-lived access token for applications running in Google Cloud Platform.   # noqa: E501

        Use the GCP Authenticator API to send an authentication request from a Google Cloud service to Conjur.  For more information, see [the documentation](https://docs.conjur.org/Latest/en/Content/Operations/Services/cjr-gcp-authn.htm).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_token_via_gcp_with_http_info(account, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account: Organization account name (required)
        :param str accept_encoding: Setting the Accept-Encoding header to base64 will return a pre-encoded access token
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param str jwt:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'account',
            'accept_encoding',
            'x_request_id',
            'jwt'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_token_via_gcp" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'account' is set
        if self.api_client.client_side_validation and ('account' not in local_var_params or  # noqa: E501
                                                        local_var_params['account'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `account` when calling `get_access_token_via_gcp`")  # noqa: E501

        if self.api_client.client_side_validation and 'x_request_id' in local_var_params and not re.search(r'^[a-zA-Z\d-]{1,255}$', local_var_params['x_request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `x_request_id` when calling `get_access_token_via_gcp`, must conform to the pattern `/^[a-zA-Z\d-]{1,255}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'account' in local_var_params:
            path_params['account'] = local_var_params['account']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept_encoding' in local_var_params:
            header_params['Accept-Encoding'] = local_var_params['accept_encoding']  # noqa: E501
        if 'x_request_id' in local_var_params:
            header_params['X-Request-Id'] = local_var_params['x_request_id']  # noqa: E501

        form_params = []
        local_var_files = {}
        if 'jwt' in local_var_params:
            form_params.append(('jwt', local_var_params['jwt']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/authn-gcp/{account}/authenticate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access_token_via_jwt(self, account, service_id, **kwargs):  # noqa: E501
        """Gets a short-lived access token for applications using JSON Web Token (JWT) to access the Conjur API.   # noqa: E501

        Use the JWT Authenticator to leverage the identity layer provided by JWT to authenticate with Conjur.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_token_via_jwt(account, service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account: Organization account name (required)
        :param str service_id: URL-Encoded authenticator service ID (required)
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param str jwt:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_access_token_via_jwt_with_http_info(account, service_id, **kwargs)  # noqa: E501

    def get_access_token_via_jwt_with_http_info(self, account, service_id, **kwargs):  # noqa: E501
        """Gets a short-lived access token for applications using JSON Web Token (JWT) to access the Conjur API.   # noqa: E501

        Use the JWT Authenticator to leverage the identity layer provided by JWT to authenticate with Conjur.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_token_via_jwt_with_http_info(account, service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account: Organization account name (required)
        :param str service_id: URL-Encoded authenticator service ID (required)
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param str jwt:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'account',
            'service_id',
            'x_request_id',
            'jwt'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_token_via_jwt" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'account' is set
        if self.api_client.client_side_validation and ('account' not in local_var_params or  # noqa: E501
                                                        local_var_params['account'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `account` when calling `get_access_token_via_jwt`")  # noqa: E501
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `get_access_token_via_jwt`")  # noqa: E501

        if self.api_client.client_side_validation and ('account' in local_var_params and  # noqa: E501
                                                        len(local_var_params['account']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `account` when calling `get_access_token_via_jwt`, length must be greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and 'x_request_id' in local_var_params and not re.search(r'^[a-zA-Z\d-]{1,255}$', local_var_params['x_request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `x_request_id` when calling `get_access_token_via_jwt`, must conform to the pattern `/^[a-zA-Z\d-]{1,255}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'account' in local_var_params:
            path_params['account'] = local_var_params['account']  # noqa: E501
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_request_id' in local_var_params:
            header_params['X-Request-Id'] = local_var_params['x_request_id']  # noqa: E501

        form_params = []
        local_var_files = {}
        if 'jwt' in local_var_params:
            form_params.append(('jwt', local_var_params['jwt']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/authn-jwt/{service_id}/{account}/authenticate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access_token_via_jwt_with_id(self, account, id, service_id, **kwargs):  # noqa: E501
        """Gets a short-lived access token for applications using JSON Web Token (JWT) to access the Conjur API. Covers the case of use of optional URL parameter \"ID\"   # noqa: E501

        Use the JWT Authenticator to leverage the identity layer provided by JWT to authenticate with Conjur.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_token_via_jwt_with_id(account, id, service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account: Organization account name (required)
        :param str id: Organization user id (required)
        :param str service_id: URL-Encoded authenticator service ID (required)
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param str jwt:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_access_token_via_jwt_with_id_with_http_info(account, id, service_id, **kwargs)  # noqa: E501

    def get_access_token_via_jwt_with_id_with_http_info(self, account, id, service_id, **kwargs):  # noqa: E501
        """Gets a short-lived access token for applications using JSON Web Token (JWT) to access the Conjur API. Covers the case of use of optional URL parameter \"ID\"   # noqa: E501

        Use the JWT Authenticator to leverage the identity layer provided by JWT to authenticate with Conjur.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_token_via_jwt_with_id_with_http_info(account, id, service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account: Organization account name (required)
        :param str id: Organization user id (required)
        :param str service_id: URL-Encoded authenticator service ID (required)
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param str jwt:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'account',
            'id',
            'service_id',
            'x_request_id',
            'jwt'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_token_via_jwt_with_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'account' is set
        if self.api_client.client_side_validation and ('account' not in local_var_params or  # noqa: E501
                                                        local_var_params['account'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `account` when calling `get_access_token_via_jwt_with_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `get_access_token_via_jwt_with_id`")  # noqa: E501
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `get_access_token_via_jwt_with_id`")  # noqa: E501

        if self.api_client.client_side_validation and ('account' in local_var_params and  # noqa: E501
                                                        len(local_var_params['account']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `account` when calling `get_access_token_via_jwt_with_id`, length must be greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and ('id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['id']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `id` when calling `get_access_token_via_jwt_with_id`, length must be greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and 'x_request_id' in local_var_params and not re.search(r'^[a-zA-Z\d-]{1,255}$', local_var_params['x_request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `x_request_id` when calling `get_access_token_via_jwt_with_id`, must conform to the pattern `/^[a-zA-Z\d-]{1,255}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'account' in local_var_params:
            path_params['account'] = local_var_params['account']  # noqa: E501
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_request_id' in local_var_params:
            header_params['X-Request-Id'] = local_var_params['x_request_id']  # noqa: E501

        form_params = []
        local_var_files = {}
        if 'jwt' in local_var_params:
            form_params.append(('jwt', local_var_params['jwt']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/authn-jwt/{service_id}/{account}/{id}/authenticate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access_token_via_kubernetes(self, service_id, account, login, **kwargs):  # noqa: E501
        """Gets a short-lived access token for applications running in Kubernetes.  # noqa: E501

        The access token is used to communicate to the REST API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that was granted during authorization.  For API usage, the base64-encoded access token is ordinarily passed as an HTTP Authorization header as `Authorization: Token token=<base64-encoded token>`.  The `login` must be URL encoded and the host ID must have the prefix `host/`. For example, the host webserver would login as `host/webserver`, and would be encoded as `host%2Fwebserver`.  The `service_id`, if given, must be URL encoded. For example, `prod/gke` must be encoded as `prod%2Fgke`.  To authenticate to Conjur using this endpoint, reference the detailed documentation: [Kubernetes Authenticator](https://docs.conjur.org/Latest/en/Content/Operations/Services/k8s_auth.htm) (`authn-k8s`).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_token_via_kubernetes(service_id, account, login, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: URL-Encoded authenticator service ID (required)
        :param str account: Organization account name (required)
        :param str login: URL-encoded login name. For users, it’s the user ID. For hosts, the login name is `host/<host-id>` (required)
        :param str accept_encoding: Setting the Accept-Encoding header to base64 will return a pre-encoded access token
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_access_token_via_kubernetes_with_http_info(service_id, account, login, **kwargs)  # noqa: E501

    def get_access_token_via_kubernetes_with_http_info(self, service_id, account, login, **kwargs):  # noqa: E501
        """Gets a short-lived access token for applications running in Kubernetes.  # noqa: E501

        The access token is used to communicate to the REST API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that was granted during authorization.  For API usage, the base64-encoded access token is ordinarily passed as an HTTP Authorization header as `Authorization: Token token=<base64-encoded token>`.  The `login` must be URL encoded and the host ID must have the prefix `host/`. For example, the host webserver would login as `host/webserver`, and would be encoded as `host%2Fwebserver`.  The `service_id`, if given, must be URL encoded. For example, `prod/gke` must be encoded as `prod%2Fgke`.  To authenticate to Conjur using this endpoint, reference the detailed documentation: [Kubernetes Authenticator](https://docs.conjur.org/Latest/en/Content/Operations/Services/k8s_auth.htm) (`authn-k8s`).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_token_via_kubernetes_with_http_info(service_id, account, login, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: URL-Encoded authenticator service ID (required)
        :param str account: Organization account name (required)
        :param str login: URL-encoded login name. For users, it’s the user ID. For hosts, the login name is `host/<host-id>` (required)
        :param str accept_encoding: Setting the Accept-Encoding header to base64 will return a pre-encoded access token
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id',
            'account',
            'login',
            'accept_encoding',
            'x_request_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_token_via_kubernetes" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `get_access_token_via_kubernetes`")  # noqa: E501
        # verify the required parameter 'account' is set
        if self.api_client.client_side_validation and ('account' not in local_var_params or  # noqa: E501
                                                        local_var_params['account'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `account` when calling `get_access_token_via_kubernetes`")  # noqa: E501
        # verify the required parameter 'login' is set
        if self.api_client.client_side_validation and ('login' not in local_var_params or  # noqa: E501
                                                        local_var_params['login'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `login` when calling `get_access_token_via_kubernetes`")  # noqa: E501

        if self.api_client.client_side_validation and ('account' in local_var_params and  # noqa: E501
                                                        len(local_var_params['account']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `account` when calling `get_access_token_via_kubernetes`, length must be greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and ('login' in local_var_params and  # noqa: E501
                                                        len(local_var_params['login']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `login` when calling `get_access_token_via_kubernetes`, length must be greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and 'x_request_id' in local_var_params and not re.search(r'^[a-zA-Z\d-]{1,255}$', local_var_params['x_request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `x_request_id` when calling `get_access_token_via_kubernetes`, must conform to the pattern `/^[a-zA-Z\d-]{1,255}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501
        if 'account' in local_var_params:
            path_params['account'] = local_var_params['account']  # noqa: E501
        if 'login' in local_var_params:
            path_params['login'] = local_var_params['login']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept_encoding' in local_var_params:
            header_params['Accept-Encoding'] = local_var_params['accept_encoding']  # noqa: E501
        if 'x_request_id' in local_var_params:
            header_params['X-Request-Id'] = local_var_params['x_request_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['conjurKubernetesMutualTls']  # noqa: E501

        return self.api_client.call_api(
            '/authn-k8s/{service_id}/{account}/{login}/authenticate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access_token_via_ldap(self, service_id, account, login, **kwargs):  # noqa: E501
        """Gets a short-lived access token for users and hosts using their LDAP identity to access the Conjur API.   # noqa: E501

        The access token is used to communicate to the REST API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that was granted during authorization.  For API usage, the base64-encoded access token is ordinarily passed as an HTTP Authorization header as `Authorization: Token token=<base64-encoded token>`.  The `login` must be URL encoded. For example, `alice@devops` must be encoded as `alice%40devops`.  The `service_id`, if given, must be URL encoded. For example, `prod/gke` must be encoded as `prod%2Fgke`.  For host authentication, the `login` is the host ID with the prefix `host/`. For example, the host webserver would login as `host/webserver`, and would be encoded as `host%2Fwebserver`.  To authenticate to Conjur using a LDAP, reference the detailed documentation: [LDAP Authenticator](https://docs.conjur.org/Latest/en/Content/Integrations/ldap/ldap_authenticator.html) (`authn-ldap`).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_token_via_ldap(service_id, account, login, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: URL-Encoded authenticator service ID (required)
        :param str account: Organization account name (required)
        :param str login: URL-encoded login name. For users, it’s the user ID. For hosts, the login name is `host/<host-id>` (required)
        :param str accept_encoding: Setting the Accept-Encoding header to base64 will return a pre-encoded access token
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param str body: API key
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_access_token_via_ldap_with_http_info(service_id, account, login, **kwargs)  # noqa: E501

    def get_access_token_via_ldap_with_http_info(self, service_id, account, login, **kwargs):  # noqa: E501
        """Gets a short-lived access token for users and hosts using their LDAP identity to access the Conjur API.   # noqa: E501

        The access token is used to communicate to the REST API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that was granted during authorization.  For API usage, the base64-encoded access token is ordinarily passed as an HTTP Authorization header as `Authorization: Token token=<base64-encoded token>`.  The `login` must be URL encoded. For example, `alice@devops` must be encoded as `alice%40devops`.  The `service_id`, if given, must be URL encoded. For example, `prod/gke` must be encoded as `prod%2Fgke`.  For host authentication, the `login` is the host ID with the prefix `host/`. For example, the host webserver would login as `host/webserver`, and would be encoded as `host%2Fwebserver`.  To authenticate to Conjur using a LDAP, reference the detailed documentation: [LDAP Authenticator](https://docs.conjur.org/Latest/en/Content/Integrations/ldap/ldap_authenticator.html) (`authn-ldap`).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_token_via_ldap_with_http_info(service_id, account, login, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: URL-Encoded authenticator service ID (required)
        :param str account: Organization account name (required)
        :param str login: URL-encoded login name. For users, it’s the user ID. For hosts, the login name is `host/<host-id>` (required)
        :param str accept_encoding: Setting the Accept-Encoding header to base64 will return a pre-encoded access token
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param str body: API key
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id',
            'account',
            'login',
            'accept_encoding',
            'x_request_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_token_via_ldap" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `get_access_token_via_ldap`")  # noqa: E501
        # verify the required parameter 'account' is set
        if self.api_client.client_side_validation and ('account' not in local_var_params or  # noqa: E501
                                                        local_var_params['account'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `account` when calling `get_access_token_via_ldap`")  # noqa: E501
        # verify the required parameter 'login' is set
        if self.api_client.client_side_validation and ('login' not in local_var_params or  # noqa: E501
                                                        local_var_params['login'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `login` when calling `get_access_token_via_ldap`")  # noqa: E501

        if self.api_client.client_side_validation and ('account' in local_var_params and  # noqa: E501
                                                        len(local_var_params['account']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `account` when calling `get_access_token_via_ldap`, length must be greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and ('login' in local_var_params and  # noqa: E501
                                                        len(local_var_params['login']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `login` when calling `get_access_token_via_ldap`, length must be greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and 'x_request_id' in local_var_params and not re.search(r'^[a-zA-Z\d-]{1,255}$', local_var_params['x_request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `x_request_id` when calling `get_access_token_via_ldap`, must conform to the pattern `/^[a-zA-Z\d-]{1,255}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501
        if 'account' in local_var_params:
            path_params['account'] = local_var_params['account']  # noqa: E501
        if 'login' in local_var_params:
            path_params['login'] = local_var_params['login']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept_encoding' in local_var_params:
            header_params['Accept-Encoding'] = local_var_params['accept_encoding']  # noqa: E501
        if 'x_request_id' in local_var_params:
            header_params['X-Request-Id'] = local_var_params['x_request_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/authn-ldap/{service_id}/{account}/{login}/authenticate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access_token_via_oidc(self, service_id, account, **kwargs):  # noqa: E501
        """Gets a short-lived access token for applications using OpenID Connect (OIDC) to access the Conjur API.   # noqa: E501

        Use the OIDC Authenticator to leverage the identity layer provided by OIDC to authenticate with Conjur.  For more information see [the documentation](https://docs.conjur.org/Latest/en/Content/OIDC/OIDC.htm).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_token_via_oidc(service_id, account, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: URL-Encoded authenticator service ID (required)
        :param str account: Organization account name (required)
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param str id_token:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_access_token_via_oidc_with_http_info(service_id, account, **kwargs)  # noqa: E501

    def get_access_token_via_oidc_with_http_info(self, service_id, account, **kwargs):  # noqa: E501
        """Gets a short-lived access token for applications using OpenID Connect (OIDC) to access the Conjur API.   # noqa: E501

        Use the OIDC Authenticator to leverage the identity layer provided by OIDC to authenticate with Conjur.  For more information see [the documentation](https://docs.conjur.org/Latest/en/Content/OIDC/OIDC.htm).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_token_via_oidc_with_http_info(service_id, account, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: URL-Encoded authenticator service ID (required)
        :param str account: Organization account name (required)
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param str id_token:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id',
            'account',
            'x_request_id',
            'id_token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_token_via_oidc" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `get_access_token_via_oidc`")  # noqa: E501
        # verify the required parameter 'account' is set
        if self.api_client.client_side_validation and ('account' not in local_var_params or  # noqa: E501
                                                        local_var_params['account'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `account` when calling `get_access_token_via_oidc`")  # noqa: E501

        if self.api_client.client_side_validation and ('account' in local_var_params and  # noqa: E501
                                                        len(local_var_params['account']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `account` when calling `get_access_token_via_oidc`, length must be greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and 'x_request_id' in local_var_params and not re.search(r'^[a-zA-Z\d-]{1,255}$', local_var_params['x_request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `x_request_id` when calling `get_access_token_via_oidc`, must conform to the pattern `/^[a-zA-Z\d-]{1,255}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501
        if 'account' in local_var_params:
            path_params['account'] = local_var_params['account']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_request_id' in local_var_params:
            header_params['X-Request-Id'] = local_var_params['x_request_id']  # noqa: E501

        form_params = []
        local_var_files = {}
        if 'id_token' in local_var_params:
            form_params.append(('id_token', local_var_params['id_token']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/authn-oidc/{service_id}/{account}/authenticate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_api_key(self, account, **kwargs):  # noqa: E501
        """Gets the API key of a user given the username and password via HTTP Basic Authentication.   # noqa: E501

        Passwords are stored in the Conjur database using `bcrypt` with a work factor of 12. Therefore, login is a fairly expensive operation. However, once the API key is obtained, it may be used to inexpensively obtain access tokens by calling the Authenticate method. An access token is required to use most other parts of the Conjur API.  The Basic authentication-compliant header is formed by: 1. Concatenating the role's name, a literal colon character ':',    and the password or API key to create the authentication string. 2. Base64-encoding the authentication string. 3. Prefixing the authentication string with the scheme: `Basic `    (note the required space). 4. Providing the result as the value of the `Authorization` HTTP header:    `Authorization: Basic <authentication string>`.  Your HTTP/REST client probably provides HTTP basic authentication support. For example, `curl` and all of the Conjur client libraries provide this.  Note that machine roles (Hosts) do not have passwords and do not need to use this endpoint.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_api_key(account, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account: Organization account name (required)
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_api_key_with_http_info(account, **kwargs)  # noqa: E501

    def get_api_key_with_http_info(self, account, **kwargs):  # noqa: E501
        """Gets the API key of a user given the username and password via HTTP Basic Authentication.   # noqa: E501

        Passwords are stored in the Conjur database using `bcrypt` with a work factor of 12. Therefore, login is a fairly expensive operation. However, once the API key is obtained, it may be used to inexpensively obtain access tokens by calling the Authenticate method. An access token is required to use most other parts of the Conjur API.  The Basic authentication-compliant header is formed by: 1. Concatenating the role's name, a literal colon character ':',    and the password or API key to create the authentication string. 2. Base64-encoding the authentication string. 3. Prefixing the authentication string with the scheme: `Basic `    (note the required space). 4. Providing the result as the value of the `Authorization` HTTP header:    `Authorization: Basic <authentication string>`.  Your HTTP/REST client probably provides HTTP basic authentication support. For example, `curl` and all of the Conjur client libraries provide this.  Note that machine roles (Hosts) do not have passwords and do not need to use this endpoint.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_api_key_with_http_info(account, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account: Organization account name (required)
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'account',
            'x_request_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_api_key" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'account' is set
        if self.api_client.client_side_validation and ('account' not in local_var_params or  # noqa: E501
                                                        local_var_params['account'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `account` when calling `get_api_key`")  # noqa: E501

        if self.api_client.client_side_validation and ('account' in local_var_params and  # noqa: E501
                                                        len(local_var_params['account']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `account` when calling `get_api_key`, length must be greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and 'x_request_id' in local_var_params and not re.search(r'^[a-zA-Z\d-]{1,255}$', local_var_params['x_request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `x_request_id` when calling `get_api_key`, must conform to the pattern `/^[a-zA-Z\d-]{1,255}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'account' in local_var_params:
            path_params['account'] = local_var_params['account']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_request_id' in local_var_params:
            header_params['X-Request-Id'] = local_var_params['x_request_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/authn/{account}/login', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_api_key_via_ldap(self, service_id, account, **kwargs):  # noqa: E501
        """Gets the Conjur API key of a user given the LDAP username and password via HTTP Basic Authentication.   # noqa: E501

        Exchange your LDAP credentials for a Conjur API key. Once the API key is obtained, it may be used to inexpensively obtain access tokens by calling the Authenticate method. An access token is required to use most other parts of the Conjur API.  The Basic authentication-compliant header is formed by: 1. Concatenating the LDAP username, a literal colon character ':',    and the password to create the authentication string. 2. Base64-encoding the authentication string. 3. Prefixing the authentication string with the scheme: `Basic `    (note the required space). 4. Providing the result as the value of the `Authorization` HTTP header:    `Authorization: Basic <authentication string>`.  Your HTTP/REST client probably provides HTTP basic authentication support.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_api_key_via_ldap(service_id, account, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: URL-Encoded authenticator service ID (required)
        :param str account: Organization account name (required)
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_api_key_via_ldap_with_http_info(service_id, account, **kwargs)  # noqa: E501

    def get_api_key_via_ldap_with_http_info(self, service_id, account, **kwargs):  # noqa: E501
        """Gets the Conjur API key of a user given the LDAP username and password via HTTP Basic Authentication.   # noqa: E501

        Exchange your LDAP credentials for a Conjur API key. Once the API key is obtained, it may be used to inexpensively obtain access tokens by calling the Authenticate method. An access token is required to use most other parts of the Conjur API.  The Basic authentication-compliant header is formed by: 1. Concatenating the LDAP username, a literal colon character ':',    and the password to create the authentication string. 2. Base64-encoding the authentication string. 3. Prefixing the authentication string with the scheme: `Basic `    (note the required space). 4. Providing the result as the value of the `Authorization` HTTP header:    `Authorization: Basic <authentication string>`.  Your HTTP/REST client probably provides HTTP basic authentication support.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_api_key_via_ldap_with_http_info(service_id, account, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: URL-Encoded authenticator service ID (required)
        :param str account: Organization account name (required)
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id',
            'account',
            'x_request_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_api_key_via_ldap" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `get_api_key_via_ldap`")  # noqa: E501
        # verify the required parameter 'account' is set
        if self.api_client.client_side_validation and ('account' not in local_var_params or  # noqa: E501
                                                        local_var_params['account'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `account` when calling `get_api_key_via_ldap`")  # noqa: E501

        if self.api_client.client_side_validation and ('account' in local_var_params and  # noqa: E501
                                                        len(local_var_params['account']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `account` when calling `get_api_key_via_ldap`, length must be greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and 'x_request_id' in local_var_params and not re.search(r'^[a-zA-Z\d-]{1,255}$', local_var_params['x_request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `x_request_id` when calling `get_api_key_via_ldap`, must conform to the pattern `/^[a-zA-Z\d-]{1,255}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501
        if 'account' in local_var_params:
            path_params['account'] = local_var_params['account']  # noqa: E501

        query_params = []

        header_params = {}
        if 'x_request_id' in local_var_params:
            header_params['X-Request-Id'] = local_var_params['x_request_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/authn-ldap/{service_id}/{account}/login', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def k8s_inject_client_cert(self, service_id, body, **kwargs):  # noqa: E501
        """For applications running in Kubernetes; sends Conjur a certificate signing request (CSR) and requests a client certificate injected into the application's Kubernetes pod.   # noqa: E501

        This request sends a Certificate Signing Request to Conjur, which uses the Kubernetes API to inject a client certificate into the application pod.  This endpoint requires a properly configured Conjur Certificate Authority service alongside a properly configured and enabled Kubernetes authenticator. For detailed instructions, see [the documentation](https://docs.conjur.org/Latest/en/Content/Integrations/kubernetes.htm).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.k8s_inject_client_cert(service_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: URL-Encoded authenticator service ID (required)
        :param str body: Valid certificate signing request that includes the host identity suffix as the CSR common name  (required)
        :param str host_id_prefix: Dot-separated policy tree, prefixed by `host.`, where the application identity is defined
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.k8s_inject_client_cert_with_http_info(service_id, body, **kwargs)  # noqa: E501

    def k8s_inject_client_cert_with_http_info(self, service_id, body, **kwargs):  # noqa: E501
        """For applications running in Kubernetes; sends Conjur a certificate signing request (CSR) and requests a client certificate injected into the application's Kubernetes pod.   # noqa: E501

        This request sends a Certificate Signing Request to Conjur, which uses the Kubernetes API to inject a client certificate into the application pod.  This endpoint requires a properly configured Conjur Certificate Authority service alongside a properly configured and enabled Kubernetes authenticator. For detailed instructions, see [the documentation](https://docs.conjur.org/Latest/en/Content/Integrations/kubernetes.htm).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.k8s_inject_client_cert_with_http_info(service_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: URL-Encoded authenticator service ID (required)
        :param str body: Valid certificate signing request that includes the host identity suffix as the CSR common name  (required)
        :param str host_id_prefix: Dot-separated policy tree, prefixed by `host.`, where the application identity is defined
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id',
            'body',
            'host_id_prefix',
            'x_request_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method k8s_inject_client_cert" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `k8s_inject_client_cert`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `k8s_inject_client_cert`")  # noqa: E501

        if self.api_client.client_side_validation and 'x_request_id' in local_var_params and not re.search(r'^[a-zA-Z\d-]{1,255}$', local_var_params['x_request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `x_request_id` when calling `k8s_inject_client_cert`, must conform to the pattern `/^[a-zA-Z\d-]{1,255}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'host_id_prefix' in local_var_params:
            header_params['Host-Id-Prefix'] = local_var_params['host_id_prefix']  # noqa: E501
        if 'x_request_id' in local_var_params:
            header_params['X-Request-Id'] = local_var_params['x_request_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'conjurAuth', 'conjurKubernetesMutualTls']  # noqa: E501

        return self.api_client.call_api(
            '/authn-k8s/{service_id}/inject_client_cert', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def rotate_api_key(self, account, **kwargs):  # noqa: E501
        """Rotates a role's API key.  # noqa: E501

        Any role can rotate its own API key. The name and password (for users) or current API key (for hosts and users) of the role must be provided via HTTP Basic Authorization.  To rotate another role's API key, you may provide your name and password (for users) or current API key (for hosts and users) via HTTP Basic Authorization with the request. Alternatively, you may provide your Conjur access token via the standard Conjur `Authorization` header.  The Basic authentication-compliant header is formed by: 1. Concatenating the role's name, a literal colon character ':',    and the password or API key to create the authentication string. 2. Base64-encoding the authentication string. 3. Prefixing the authentication string with the scheme: `Basic `    (note the required space). 4. Providing the result as the value of the `Authorization` HTTP header:    `Authorization: Basic <authentication string>`.  Your HTTP/REST client probably provides HTTP basic authentication support. For example, `curl` and all of the Conjur client libraries provide this.  If using the Conjur `Authorization` header, its value should be set to `Token token=<base64-encoded access token>`.  Note that the body of the request must be the empty string.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rotate_api_key(account, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account: Organization account name (required)
        :param str role: (**Optional**) role specifier in `{kind}:{identifier}` format  ##### Permissions required  `update` privilege on the role whose API key is being rotated. 
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.rotate_api_key_with_http_info(account, **kwargs)  # noqa: E501

    def rotate_api_key_with_http_info(self, account, **kwargs):  # noqa: E501
        """Rotates a role's API key.  # noqa: E501

        Any role can rotate its own API key. The name and password (for users) or current API key (for hosts and users) of the role must be provided via HTTP Basic Authorization.  To rotate another role's API key, you may provide your name and password (for users) or current API key (for hosts and users) via HTTP Basic Authorization with the request. Alternatively, you may provide your Conjur access token via the standard Conjur `Authorization` header.  The Basic authentication-compliant header is formed by: 1. Concatenating the role's name, a literal colon character ':',    and the password or API key to create the authentication string. 2. Base64-encoding the authentication string. 3. Prefixing the authentication string with the scheme: `Basic `    (note the required space). 4. Providing the result as the value of the `Authorization` HTTP header:    `Authorization: Basic <authentication string>`.  Your HTTP/REST client probably provides HTTP basic authentication support. For example, `curl` and all of the Conjur client libraries provide this.  If using the Conjur `Authorization` header, its value should be set to `Token token=<base64-encoded access token>`.  Note that the body of the request must be the empty string.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rotate_api_key_with_http_info(account, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account: Organization account name (required)
        :param str role: (**Optional**) role specifier in `{kind}:{identifier}` format  ##### Permissions required  `update` privilege on the role whose API key is being rotated. 
        :param str x_request_id: Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'account',
            'role',
            'x_request_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rotate_api_key" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'account' is set
        if self.api_client.client_side_validation and ('account' not in local_var_params or  # noqa: E501
                                                        local_var_params['account'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `account` when calling `rotate_api_key`")  # noqa: E501

        if self.api_client.client_side_validation and ('account' in local_var_params and  # noqa: E501
                                                        len(local_var_params['account']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `account` when calling `rotate_api_key`, length must be greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and ('role' in local_var_params and  # noqa: E501
                                                        len(local_var_params['role']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `role` when calling `rotate_api_key`, length must be greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and 'x_request_id' in local_var_params and not re.search(r'^[a-zA-Z\d-]{1,255}$', local_var_params['x_request_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `x_request_id` when calling `rotate_api_key`, must conform to the pattern `/^[a-zA-Z\d-]{1,255}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'account' in local_var_params:
            path_params['account'] = local_var_params['account']  # noqa: E501

        query_params = []
        if 'role' in local_var_params and local_var_params['role'] is not None:  # noqa: E501
            query_params.append(('role', local_var_params['role']))  # noqa: E501

        header_params = {}
        if 'x_request_id' in local_var_params:
            header_params['X-Request-Id'] = local_var_params['x_request_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'conjurAuth']  # noqa: E501

        return self.api_client.call_api(
            '/authn/{account}/api_key', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
